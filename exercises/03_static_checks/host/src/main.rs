// Static checks in guest
//
// A common pattern that is needed is the ability to make assertions about data that is being passed
// into the zkvm. The goal here is to only allow inputs which value is greater than 10 execute.
// For this exercise, you will just modify the guest in ../guest/src/main such that
// all of the test vectors here pass. The check you will add will constrain the program such that
// no u32 values under 10 will execute, and all values above will.

use std::fs;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use risc0_zkvm::{compute_image_id, default_prover, sha::Digest, ExecutorEnv};

// I AM NOT DONE

fn main() -> anyhow::Result<()> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let (guest_elf, guest_id) = guest_bin();

    // DO NOT MODIFY THIS OR ANYTHING IN THE HOST
    test_vectors(
        &guest_elf,
        guest_id,
        [
            TestVector {
                input: 7,
                should_fail: true,
            },
            TestVector {
                input: 11,
                should_fail: false,
            },
            TestVector {
                input: 9,
                should_fail: true,
            },
            TestVector {
                input: u32::MAX,
                should_fail: false,
            },
            TestVector {
                input: 10,
                should_fail: true,
            },
        ],
    )?;

    Ok(())
}

struct TestVector {
    input: u32,
    should_fail: bool,
}

fn test_vectors(
    guest_elf: &[u8],
    guest_id: Digest,
    vectors: impl IntoIterator<Item = TestVector>,
) -> anyhow::Result<()> {
    for TestVector { input, should_fail } in vectors {
        let env = ExecutorEnv::builder().write(&input)?.build()?;

        // Obtain the default prover.
        let prover = default_prover();

        // Proof information by proving the specified ELF binary.
        // This struct contains the receipt along with statistics about execution of the guest
        let prove_info = if let Ok(receipt) = prover.prove(env, &guest_elf) {
            assert!(!should_fail, "Expected failure for value {}", input);
            receipt
        } else {
            assert!(should_fail, "Expected success for value {}", input);
            continue;
        };
        let receipt = prove_info.receipt;

        assert_eq!(receipt.journal.decode::<u32>()?, input);

        // The receipt was verified at the end of proving, but the below code is an
        // example of how someone else could verify this receipt.
        receipt.verify(guest_id)?;
    }
    Ok(())
}

// Note: utility to retrieve the guest binary and image ID from ../guest. Do not modify.
fn guest_bin() -> (Vec<u8>, Digest) {
    let guest_elf = fs::read(
        fs::canonicalize(env!("CARGO_MANIFEST_DIR"))
            .unwrap()
            // Note: Somewhat hacky to infer the target directory, probably a cleaner way to do this
            // https://github.com/rust-lang/cargo/issues/9661
            .parent()
            .unwrap()
            .join("target")
            .join("riscv32im-risc0-zkvm-elf")
            .join("release")
            .join("guest"),
    )
    .unwrap();
    let guest_id = compute_image_id(&guest_elf).unwrap();
    (guest_elf, guest_id)
}

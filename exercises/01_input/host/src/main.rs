// Guest input
//
// TODO docs

use std::fs;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use risc0_zkvm::{compute_image_id, default_prover, sha::Digest, ExecutorEnv};

// I AM NOT DONE

fn main() -> anyhow::Result<()> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let (guest_elf, guest_id) = guest_bin();

    // TODO update the executor env to provide some input.
    let env = ExecutorEnv::builder().build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, &guest_elf).unwrap();

    println!("Guest ran the program successfully!");

    // extract the receipt.
    let receipt = prove_info.receipt;

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(guest_id).unwrap();

    Ok(())
}

// Note: utility to retrieve the guest binary and image ID from ../guest. Do not modify.
fn guest_bin() -> (Vec<u8>, Digest) {
    let guest_elf = fs::read(
        fs::canonicalize(env!("CARGO_MANIFEST_DIR"))
            .unwrap()
            // Note: Somewhat hacky to infer the target directory, probably a cleaner way to do this
            // https://github.com/rust-lang/cargo/issues/9661
            .parent()
            .unwrap()
            .join("target")
            .join("riscv32im-risc0-zkvm-elf")
            .join("release")
            .join("guest"),
    )
    .unwrap();
    let guest_id = compute_image_id(&guest_elf).unwrap();
    (guest_elf, guest_id)
}

// intro1.rs
//
// About this `I AM NOT DONE` thing:
// We sometimes encourage you to keep trying things on a given exercise, even
// after you already figured it out. If you got everything working and feel
// ready for the next exercise, remove the `I AM NOT DONE` comment below.
//
// If you're running this using `rustlings watch`: The exercise file will be
// reloaded when you change one of the lines below! Try adding a `println!`
// line, or try changing what it outputs in your terminal. Try removing a
// semicolon and see what happens!
//
// Execute `rustlings hint intro1` or use the `hint` watch subcommand for a
// hint.

use std::fs;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use risc0_zkvm::{compute_image_id, default_prover, sha::Digest, ExecutorEnv};

// I AM NOT DONE

fn main() -> anyhow::Result<()> {
    // TODO update doc
    println!("Hello and");
    println!(r#"       welcome to...           "#);
    println!(r#"           _ _                 "#);
    println!(r#"          | (_)                "#);
    println!(r#"  _ __ ___| |_ _ __   __ _ ___ "#);
    println!(r#" | '__|_  / | | '_ \ / _` / __|"#);
    println!(r#" | |   / /| | | | | | (_| \__ \"#);
    println!(r#" |_|  /___|_|_|_| |_|\__, |___/"#);
    println!(r#"                      __/ |    "#);
    println!(r#"                     |___/     "#);
    println!();
    println!("This exercise compiles successfully. The remaining exercises contain a compiler");
    println!("or logic error. The central concept behind Rustlings is to fix these errors and");
    println!("solve the exercises. Good luck!");
    println!();
    println!("The source for this exercise is in `exercises/00_compiling/host/src/main.rs`.");
    println!(
        "Going forward, the source of the exercises will always be in the success/failure output."
    );
    println!();
    println!(
        "If you want to use rust-analyzer, Rust's LSP implementation, make sure your editor is set"
    );
    println!("up, and then run `rustlings lsp` before continuing.");

    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let (guest_elf, guest_id) = guest_bin();

    let env = ExecutorEnv::builder().build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, &guest_elf).unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(guest_id).unwrap();

    Ok(())
}

// Note: utility to retrieve the guest binary and image ID from ../guest
fn guest_bin() -> (Vec<u8>, Digest) {
    let guest_elf = fs::read(
        fs::canonicalize(env!("CARGO_MANIFEST_DIR"))
            .unwrap()
            // Note: Somewhat hacky to infer the target directory, probably a cleaner way to do this
            // https://github.com/rust-lang/cargo/issues/9661
            .parent()
            .unwrap()
            .join("target")
            .join("riscv32im-risc0-zkvm-elf")
            .join("release")
            .join("guest"),
    )
    .unwrap();
    let guest_id = compute_image_id(&guest_elf).unwrap();
    (guest_elf, guest_id)
}
